/**
 * Model of a proper timeout object that fires once
 */
class Alarm {
    /**
     * Number of miliseconds the function of the alarm
     * is going to take to execute
     * @type {number}
     */
    timeout;

    /**
     * Function (callback) the alarm will execute
     */
    fun;

    /**
     * Date the alarm was set
     * @type {Date}
     */
    start;

    /**
     * Date the alarm will have to end
     * @type {Date}
     */
    end;

    /**
     * Index the alarm occupies among the timeouts
     * generated by `setTimeout`
     * @type {number}
     */
    index;

    /**
     * If the alarm has already been executed
     * @type {boolean}
     */
    consumed;

    /**
     * Simple constructor
     * @constructor
     * @param {callback} fun Function the alarm will execute
     * @param {number} timeout Time (from now; in ms) it will take for the alarm to fire
     * @param {boolean} set Whether or not to start running the alarm when created (true by default)
     */
    constructor(fun, timeout, set=true) {
        this.fun = fun;
        this.timeout = timeout;
        this.consumed = false;

        let now = Date.now();

        this.start = now;
        this.end = now + timeout;
        if (set) this.set();
    }

    /**
     * Starts running the alarm.
     * 
     * After the timeout passes, it will execute its function
     * and clear itself
     */
    set() {
        this.index = setTimeout(() => {
            this.fun();
            this.clear();
        }, this.timeout);
    }

    /**
     * Clears itself from the list of timeouts
     */
    clear() {
        clearTimeout(this.index);
        this.consumed = true;
    }

    /**
     * Gets the time passed since the alarm was set
     * @returns {Date} Time passed between now and the start of the alarm
     */
    getElapsedTime() {
        return Date.now() - this.start;
    }

    /**
     * Gets the remaining time for the alarm to be fired
     * @returns {Date} Time difference between now and the end of the alarm
     */
    getLeftTime() {
        return this.end - Date.now();
    }
}

class Apple extends HTMLDivElement {
    /**
     * X position of an apple in a board
     * @type {number}
     */
    x;

    /**
     * Y position of an apple in a board
     * @type {number}
     */
    y;

    /**
     * Maximum points a snake can get for capturing
     * this apple
     * @type {number}
     */
    maxPoints;

    /**
     * Maximum time the snake will be available to be captured
     * @type {number}
     */
    timeOut;

    /**
     * Index of the timeout function to remove the apple from a board
     * once the `timeout` variable has been exhausted
     * @type {number}
     */
    timeOutIndex;

    /**
     * If the apple is still available to be captured by a snake
     * @type {boolean}
     */
    isAvailable;

    constructor() {
        super();
    }

    setTimeOut() {
        this.timeOutIndex = setTimeout(() => {
            this.disable();
            this.clearTimeOut();
        }, this.timeOut);
    }

    clearTimeOut() {
        clearTimeout(this.timeOutIndex);
    }

    disable() {
        this.remove();
        this.isAvailable = false;
    }

    capture() {
        clearTimeout();
    }
}

export { Alarm, Apple }